<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>heap_ | Xcs</title><meta name="author" content="XC-lei"><meta name="copyright" content="XC-lei"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="[TOC] 堆介绍前言堆是一块需要动态管理的内存，glibc是实现堆管理的库，为了效率更高的管理堆，引入了很多机制，这就给利用堆破坏漏洞实现代码执行提供了很多攻击面。 与堆相应的数据结构主要分为  宏观结构，包含堆的宏观信息，可以通过这些数据结构索引堆的基本信息。 微观结构，用于具体处理堆的分配与回收中的内存块。  在展开本文之前，先解释一下本文中会提到的三个重要概念：arena，bin，chun">
<meta property="og:type" content="article">
<meta property="og:title" content="heap_">
<meta property="og:url" content="http://sssxc.xyz/CTF/pwn/Heap/index.html">
<meta property="og:site_name" content="Xcs">
<meta property="og:description" content="[TOC] 堆介绍前言堆是一块需要动态管理的内存，glibc是实现堆管理的库，为了效率更高的管理堆，引入了很多机制，这就给利用堆破坏漏洞实现代码执行提供了很多攻击面。 与堆相应的数据结构主要分为  宏观结构，包含堆的宏观信息，可以通过这些数据结构索引堆的基本信息。 微观结构，用于具体处理堆的分配与回收中的内存块。  在展开本文之前，先解释一下本文中会提到的三个重要概念：arena，bin，chun">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://skymirror-1322365871.cos.ap-beijing.myqcloud.com/Image_1699885009870.jpg">
<meta property="article:published_time" content="2024-04-18T11:49:19.062Z">
<meta property="article:modified_time" content="2024-03-27T12:12:39.964Z">
<meta property="article:author" content="XC-lei">
<meta property="article:tag" content="堆漏洞">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://skymirror-1322365871.cos.ap-beijing.myqcloud.com/Image_1699885009870.jpg"><link rel="shortcut icon" href="https://skymirror-1322365871.cos.ap-beijing.myqcloud.com/7335AC25911725E74E16F7F4F0C30210.jpg"><link rel="canonical" href="http://sssxc.xyz/CTF/pwn/Heap/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://github.com/SorkinType/Agbalumo" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: XC-lei","link":"链接: ","source":"来源: Xcs","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'heap_',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-03-27 20:12:39'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.0.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (false) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://skymirror-1322365871.cos.ap-beijing.myqcloud.com/Image_1699885009870.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">6</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Xcs"><span class="site-name">Xcs</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">heap_</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-04-18T11:49:19.062Z" title="发表于 2024-04-18 19:49:19">2024-04-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-03-27T12:12:39.964Z" title="更新于 2024-03-27 20:12:39">2024-03-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/CTF/">CTF</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/CTF/pwn/">pwn</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">9.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>34分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="heap_"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><p>[TOC]</p>
<h1 id="堆介绍"><a href="#堆介绍" class="headerlink" title="堆介绍"></a>堆介绍</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>堆是一块需要动态管理的内存，glibc是实现堆管理的库，为了效率更高的管理堆，引入了很多机制，这就给利用堆破坏漏洞实现代码执行提供了很多攻击面。</strong></p>
<p>与堆相应的数据结构主要分为</p>
<ul>
<li><strong>宏观结构</strong>，包含堆的宏观信息，可以通过这些数据结构索引堆的基本信息。</li>
<li><strong>微观结构</strong>，用于具体处理堆的分配与回收中的内存块。</li>
</ul>
<p>在展开本文之前，先解释一下本文中会提到的三个重要概念：<strong>arena，bin，chunk</strong>。三者在逻辑上的蕴含关系一般如下图所示（图中的chunk严格来说应该是<strong>Free Chunk</strong>）。</p>
<p><img src="https://skymirror-1322365871.cos.ap-beijing.myqcloud.com/v2-277a7d8c938c754554d081952e36853e_720w.webp" alt="v2-277a7d8c938c754554d081952e36853e_720w"></p>
<p>三者概念的解释如下：</p>
<p><strong>arena</strong>：通过sbrk或mmap系统调用为线程分配的堆区，按线程的类型可以分为2类：</p>
<ul>
<li>main arena：主线程建立的arena；</li>
<li>thread arena：子线程建立的arena；</li>
</ul>
<p><strong>chunk</strong>：逻辑上划分的一小块内存，根据作用不同分为4类：</p>
<ul>
<li>Allocated chunk：即分配给用户且未释放的内存块；</li>
<li>Free chunk：即用户已经释放的内存块；</li>
<li>Top chunk</li>
<li>Last Remainder chunk</li>
</ul>
<p><strong>bin</strong>：一个用以保存Free chunk链表的表头信息的指针数组，按所悬挂链表的类型可以分为4类:</p>
<ul>
<li>Fast bin</li>
<li>Unsorted bin</li>
<li>Small bin</li>
<li>Large bin</li>
</ul>
<p>在这里仅需明白arena的等级大于bin的等级大于(free)chunk的等级即可，即A&gt;B&gt;C。</p>
<h2 id="malloc-and-free"><a href="#malloc-and-free" class="headerlink" title="malloc and free"></a>malloc and free</h2><h4 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h4><ul>
<li><strong>头文件</strong>：<code>stdlib</code></li>
</ul>
<ul>
<li><strong>原型</strong>：<code>void* malloc(size_t size)</code><br>所以需要根据实际你需要的类型对其强制类型转换</li>
<li><strong>返回值</strong>：<br>成功时，返回指向新分配内存的指针。为避免内存泄漏，必须用 free() 或 realloc() 解分配返回的指针。<br>失败时，返回空指针（NULL）</li>
<li><strong>参数</strong>：size - 要分配的字节数</li>
</ul>
<h5 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h5><p><strong>分配 size 字节的未初始化内存。</strong><br>若分配成功，则返回为任何拥有基础对齐的对象类型对齐的指针。</p>
<p>若 size 为零，则 malloc 的行为是实现定义的。例如可返回空指针。亦可返回非空指针；但不应当解引用这种指针，而且应将它传递给 free 以避免内存泄漏。</p>
<h4 id="free"><a href="#free" class="headerlink" title="free"></a>free</h4><ul>
<li><strong>头文件</strong>：<code>stdlib</code></li>
<li><strong>原型</strong>：<code>void free( void* ptr );</code></li>
<li><strong>参数</strong>：指向要解分配的内存的指针</li>
<li><strong>返回值</strong>：无</li>
</ul>
<p><strong>此函数接收空指针（并对其不处理）以减少特例的数量。不管分配成功与否，分配函数返回的指针都能传递给 free()</strong></p>
<h5 id="定义：-1"><a href="#定义：-1" class="headerlink" title="定义："></a>定义：</h5><p><strong>解分配之前由 malloc() 、 calloc() 、 aligned_alloc (C11 起) 或 realloc() 分配的空间。</strong></p>
<ol>
<li><p><strong>若 ptr 为空指针，则函数不进行操作</strong>。</p>
</li>
<li><p><strong>若 ptr 的值 不等于之前从 malloc() 、 calloc() 、 realloc() 或 aligned_alloc() (C11 起) 返回的值</strong>，则行为未定义。</p>
</li>
<li><p>**<em>若 ptr 所指代的内存区域已经被解分配)<em>，则行为未定义，即是说已经以ptr 为参数调用 free() 或 realloc() ，而且没有后继的 malloc() 、 calloc() 或 realloc() 调用以 ptr 为结果。</em></em></p>
</li>
<li><p><strong>若在 free() 返回后通过指针 ptr 访问内存</strong>，则行为未定义（除非另一个分配函数恰好返回等于 ptr 的值）。</p>
</li>
</ol>
<h4 id="BRK-and-MMAP"><a href="#BRK-and-MMAP" class="headerlink" title="BRK and MMAP"></a>BRK and MMAP</h4><p>从操作系统角度来看，进程分配内存有两种方式，分别由两个系统调用完成：<strong>brk</strong>和<strong>mmap</strong>（不考虑共享内存）。</p>
<p><strong>1、brk是将数据段(.data)的最高地址指针_edata往高地址推；</strong></p>
<p><strong>2、mmap是在进程的虚拟地址空间中（堆和栈中间，称为文件映射区域的地方）找一块空闲的虚拟内存。</strong></p>
<p>这两种方式分配的都是虚拟内存，没有分配物理内存。在第一次访问已分配的虚拟地址空间的时候，发生缺页中断，操作系统负责分配物理内存，然后建立虚拟内存和物理内存之间的映射关系。<br>在标准C库中，提供了malloc&#x2F;free函数分配释放内存，这两个函数底层是由brk，mmap，munmap这些系统调用实现的。</p>
<p><strong>下面以一个例子来说明内存分配的原理：</strong></p>
<p><strong>情况一、malloc小于128k的内存</strong>，使用brk分配内存，将_edata往高地址推(只分配虚拟空间，不对应物理内存(因此没有初始化)，第一次读&#x2F;写数据时，引起内核缺页中断，内核才分配对应的物理内存，然后虚拟地址空间建立映射关系)，如下图：</p>
<p><img src="https://skymirror-1322365871.cos.ap-beijing.myqcloud.com/v2-79b4a90a85756b3c9fbb3f1f8613059a_720w.webp" alt="v2-79b4a90a85756b3c9fbb3f1f8613059a_720w"></p>
<p><strong>1、进程启动的时候，其（虚拟）内存空间的初始布局如图1所示。</strong></p>
<p>其中，mmap内存映射文件是在堆和栈的中间（例如libc-2.2.93.so，其它数据文件等），为了简单起见， 省略了内存映射文件。</p>
<p>_edata指针（glibc里面定义）指向数据段的最高地址。<br><strong>2、进程调用A&#x3D;malloc(30K)以后，内存空间如图2：</strong></p>
<p>malloc函数会调用brk系统调用，将_edata指针往高地址推30K，就完成虚拟内存分配。</p>
<p><strong>你可能会问： 只要把_edata+30K就完成内存分配了？</strong>事实是这样的，_edata+30K只是完成虚拟地址的分配， A这块内存现在还是没有物理页与之对应的， 等到进程第一次读写A这块内存的时候，发生缺页中断，这个时候，内核才分配A这块内存对应的物理页。 也就是说，如果用malloc分配了A这块内容，然后从来不访问它，那么，A对应的物理页是不会被分配的。<br><strong>3、进程调用B&#x3D;malloc(40K)以后，内存空间如图3。</strong></p>
<p><strong>情况二、malloc大于128k的内存</strong>，使用mmap分配内存，在堆和栈之间找一块空闲内存分配(对应独立内存，而且初始化为0)，如下图：</p>
<p><img src="https://skymirror-1322365871.cos.ap-beijing.myqcloud.com/v2-f3a3dc92acc7f0aa5ef700bb61c29a93_720w.webp" alt="v2-f3a3dc92acc7f0aa5ef700bb61c29a93_720w"></p>
<p>4、进程调用C&#x3D;malloc(200K)以后，内存空间如图4：</p>
<p>默认情况下，malloc函数分配内存，如果请求内存大于128K（可由M_MMAP_THRESHOLD选项调节），那就不是去推_edata指针了，而是利用mmap系统调用，从堆和栈的中间分配一块虚拟内存。</p>
<p>这样做的原因：</p>
<p><strong>brk分配的内存需要等到高地址内存释放以后才能释放</strong>（例如，在B释放之前，A是不可能释放的，这就是内存碎片产生的原因，什么时候紧缩看下面），而mmap分配的内存可以单独释放。</p>
<p>5、进程调用D&#x3D;malloc(100K)以后，内存空间如图5；<br>6、进程调用free(C)以后，C对应的虚拟内存和物理内存一起释放。</p>
<p><img src="https://skymirror-1322365871.cos.ap-beijing.myqcloud.com/v2-a3ff41a835531fbf3703fa10bd45696c_720w.webp" alt="v2-a3ff41a835531fbf3703fa10bd45696c_720w"></p>
<p>7、进程调用free(B)以后，如图7所示：</p>
<p>B对应的虚拟内存和物理内存都没有释放，因为只有一个_edata指针，如果往回推，那么D这块内存怎么办呢？</p>
<p>当然，B这块内存，是可以重用的，如果这个时候再来一个40K的请求，那么malloc很可能就把B这块内存返回回去了。<br>8、进程调用free(D)以后，如图8所示：</p>
<p>B和D连接起来，变成一块140K的空闲内存。</p>
<p>9、默认情况下：</p>
<p>当最高地址空间的空闲内存超过128K（可由M_TRIM_THRESHOLD选项调节）时，执行内存紧缩操作（trim）。在上一个步骤free的时候，发现最高地址空闲内存超过128K，于是内存紧缩，变成图9所示。</p>
<h2 id="arena"><a href="#arena" class="headerlink" title="arena"></a>arena</h2><p><em><strong>内存分配区，可以理解为堆管理器所持有的内存池</strong></em></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">操作系统  --&gt;  堆管理器  --&gt;  用户</span><br><span class="line">物理内存  --&gt;  arena   --&gt;   可用内存</span><br></pre></td></tr></table></figure>

<p>堆管理器与用户的内存交易发生于arena,</p>
<p>一个进程可以有多个arena,因为一个进程可以由多个线程构 成</p>
<p><strong>调用malloc的时候，我们明明只申请了1000Byte，但是heap segment却有0x21000Byte的大小，这0x21000Byte的空间就是arena。我们申请的空间优先从arena中取出，free后也将放回到arena</strong></p>
<h3 id="arena数量"><a href="#arena数量" class="headerlink" title="arena数量"></a>arena数量</h3><p>对于不同系统，arena 数量的<a target="_blank" rel="noopener" href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/arena.c#L847">约束</a>如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">For 32 bit systems:</span><br><span class="line">     Number of arena = 2 * number of cores.</span><br><span class="line">For 64 bit systems:</span><br><span class="line">     Number of arena = 8 * number of cores.</span><br></pre></td></tr></table></figure>

<p>即，arena 对于32位系统，数量最多为核心数量2倍，64位则最多为核心数量8倍，可以用来保证多线程的堆空间分配的高效性。</p>
<p>显然，不是每一个线程都会有对应的 arena。此外，因为每个系统的核数是有限的，当线程数大于核数的二倍（超线程技术）时，就必然有线程处于等待状态，所以没有必要为每个线程分配一个 arena。</p>
<h3 id="arena-分配规则"><a href="#arena-分配规则" class="headerlink" title="arena 分配规则"></a>arena 分配规则</h3><p>Ptmalloc2通过几种数据结构来进行管理，主要有arena,heap,chunk三种层级。Chunk为分配给用户的内存的一个单位。 对于这一块内容如果感觉不是太懂，可以结合后面数据结构部分去看，其实arena和heap我感觉都是对chunk的一种组织方式，方便之后的分配，arena又是对heap的组织。</p>
<ul>
<li><code>arena</code>: 有一个main_arena，是由主线程创建的，thread_arena则为各线程创建的，当arena满了之后就不再创建而是与其他arena共享一个arena，方法为依次给各个arena上锁（查看是否有其他线程正在使用该arena），如果上锁成功（没有其他线程正在使用），则使用该arena，之后一直使用这个arena，如果无法使用则阻塞等待。</li>
<li><code>heap</code>的等级就比arena要低一些了，一个arena可以有多个heap，也是存储了堆相关的信息。</li>
<li><code>chunk</code>为分配给用户的内存的一个单位，每当我们分配一段内存的时候其实就是分配得到了一个chunk，我们就可以在chunk当中进行一定的操作了。不过为了进行动态分配，chunk本身也有一些数据（元数据），是用来指示其分配等等的数据。</li>
</ul>
<h3 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h3><p>实际内存中，main arena和thread arena的图示如下（单堆段）。</p>
<p><img src="https://skymirror-1322365871.cos.ap-beijing.myqcloud.com/v2-cf4e07813621f39ac0ef3678731632ec_720w.webp" alt="v2-cf4e07813621f39ac0ef3678731632ec_720w"></p>
<p>其中malloc_state的数据结构描述在源代码中发现该数据结构中保存着fastbinsY、top、last_remainder、bins这四个分别表示Fast bin、Top chunk、Last Remainder chunk、bins（Unsorted bin、 Small bin、Large bin）的数据。</p>
<h3 id="main-arena中的内存申请"><a href="#main-arena中的内存申请" class="headerlink" title="main arena中的内存申请"></a>main arena中的内存申请</h3><p>main arena中的内存申请的流程如下图所示：</p>
<p><img src="https://skymirror-1322365871.cos.ap-beijing.myqcloud.com/v2-b4b36697a663571a3f8f9dfed800be2d_720w.webp" alt="v2-b4b36697a663571a3f8f9dfed800be2d_720w"></p>
<h4 id="第一次申请"><a href="#第一次申请" class="headerlink" title="第一次申请"></a><strong>第一次申请</strong></h4><ul>
<li>根据申请内存空间大小是否达到mmap这一系统调用的分配阈值，决定是使用sbrk系统调用 还是mmap系统调用申请堆区。一般分配的空间比申请的要大，这样可以减少后续申请中向操作系统申请内存的次数。</li>
<li>举例而言，用户申请1000字节的内存，实际会通过sbrk系统调用产生132KB的连续堆内存区域。</li>
<li>然后将用户申请大小的内存返回。（本例中将返回1000字节的内存。）</li>
</ul>
<h4 id="后续申请"><a href="#后续申请" class="headerlink" title="后续申请"></a><strong>后续申请</strong></h4><ul>
<li>根据arena中剩余空间的大小决定是继续分配还是扩容，其中包含扩容部分的为top chunk。</li>
<li>然后将用户申请大小的内存返回。</li>
</ul>
<h3 id="thread-arena中的申请"><a href="#thread-arena中的申请" class="headerlink" title="thread arena中的申请"></a>thread arena中的申请</h3><p>thread arena中的内存申请的流程如下图所示：</p>
<p><img src="https://skymirror-1322365871.cos.ap-beijing.myqcloud.com/v2-c455d778c82cb17229b90b9219174104_720w.webp" alt="v2-c455d778c82cb17229b90b9219174104_720w"></p>
<p>其流程类似于main arena的，区别在于thread arena的堆内存是使用mmap系统调用产生的，而非同主线程一样可能会使用sbrk系统调用。</p>
<h3 id="malloc-state"><a href="#malloc-state" class="headerlink" title="malloc_state"></a>malloc_state</h3><p>该结构用于管理堆，记录每个 arena 当前申请的内存的具体状态，比如说是否有空闲 chunk，有什么大小的空闲 chunk 等等。无论是 thread arena 还是 main arena，它们都只有一个 malloc state 结构。由于 thread 的 arena 可能有多个，malloc state 结构会在最新申请的 arena 中。</p>
<p><strong>其结构如下</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">struct malloc_state &#123;</span><br><span class="line">    /* Serialize access.  */</span><br><span class="line">    __libc_lock_define(, mutex);</span><br><span class="line"></span><br><span class="line">    /* Flags (formerly in max_fast).  */</span><br><span class="line">    int flags;</span><br><span class="line"></span><br><span class="line">    /* Fastbins */</span><br><span class="line">    mfastbinptr fastbinsY[ NFASTBINS ];</span><br><span class="line"></span><br><span class="line">    /* Base of the topmost chunk -- not otherwise kept in a bin */</span><br><span class="line">    mchunkptr top;</span><br><span class="line"></span><br><span class="line">    /* The remainder from the most recent split of a small request */</span><br><span class="line">    mchunkptr last_remainder;</span><br><span class="line"></span><br><span class="line">    /* Normal bins packed as described above */</span><br><span class="line">    mchunkptr bins[ NBINS * 2 - 2 ];</span><br><span class="line"></span><br><span class="line">    /* Bitmap of bins, help to speed up the process of determinating if a given bin is definitely empty.*/</span><br><span class="line">    unsigned int binmap[ BINMAPSIZE ];</span><br><span class="line"></span><br><span class="line">    /* Linked list, points to the next arena */</span><br><span class="line">    struct malloc_state *next;</span><br><span class="line"></span><br><span class="line">    /* Linked list for free arenas.  Access to this field is serialized</span><br><span class="line">       by free_list_lock in arena.c.  */</span><br><span class="line">    struct malloc_state *next_free;</span><br><span class="line"></span><br><span class="line">    /* Number of threads attached to this arena.  0 if the arena is on</span><br><span class="line">       the free list.  Access to this field is serialized by</span><br><span class="line">       free_list_lock in arena.c.  */</span><br><span class="line">    INTERNAL_SIZE_T attached_threads;</span><br><span class="line"></span><br><span class="line">    /* Memory allocated from the system in this arena.  */</span><br><span class="line">    INTERNAL_SIZE_T system_mem;</span><br><span class="line">    INTERNAL_SIZE_T max_system_mem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>fastbinsY[NFASTBINS]<ul>
<li>存放每个 fast chunk 链表头部的指针</li>
</ul>
</li>
<li>top<ul>
<li>指向分配区的 top chunk</li>
</ul>
</li>
<li>last_reminder<ul>
<li>最新的 chunk 分割之后剩下的那部分</li>
</ul>
</li>
<li>bins<ul>
<li>用于存储 unstored bin，small bins 和 large bins 的 chunk 链表。</li>
</ul>
</li>
</ul>
<h2 id="Malloc-Chunk"><a href="#Malloc-Chunk" class="headerlink" title="Malloc_Chunk"></a>Malloc_Chunk</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p><strong>用户申请内存的单位，也是堆管理器管理内存的基本单位</strong></p>
<p><strong>当我们在调用malloc的时候，就会返回一个指针指向一个chunk的数据区域（申请的内存空间）</strong></p>
<p><strong>当程序申请的chunk被free时会被加入到相应的空闲管理列表(bin)中</strong> </p>
<p><strong>无论一个 chunk 的大小如何，处于分配状态还是释放状态，它们都使用一个统一的结构</strong>。虽然它们使用了同一个数据结构，但是根据是否被释放，它们的表现形式会有所不同。</p>
<h3 id="malloc-chunk结构"><a href="#malloc-chunk结构" class="headerlink" title="malloc chunk结构"></a>malloc chunk结构</h3><p><img src="https://skymirror-1322365871.cos.ap-beijing.myqcloud.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-03-02%20185702.png" alt="屏幕截图 2024-03-02 185702"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct malloc_chunk </span><br><span class="line">&#123;</span><br><span class="line">  INTERNAL_SIZE_T      prev_size;  /* Size of previous chunk (if free).  */</span><br><span class="line">  INTERNAL_SIZE_T      size;       /* Size in bytes, including overhead. */</span><br><span class="line"></span><br><span class="line">  struct malloc_chunk* fd;         /* double links -- used only if free. */</span><br><span class="line">  struct malloc_chunk* bk;</span><br><span class="line"></span><br><span class="line">  /* Only used for large blocks: pointer to next larger size.  */</span><br><span class="line">  struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */</span><br><span class="line">  struct malloc_chunk* bk_nextsize;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>1、prev_size：</strong>如果该chunk的物理相邻的前一个chunk是空闲的，那就用来记录前一个chunk(free chunk)的大小，否则的话用来储存前一个chunk的数据，这也就是**<u>prev_size的复用</u>**。（malloc(0xn0)和malloc(0xn8)是用的同一处地方）<br><strong>2、chunk_size：</strong>用来记录该chunk的大小，这个大小必须是2*SIZE_SZ的倍数。如果申请的内存大小不是 2 * SIZE_SZ 的整数倍，会被转换满足大小的最小的 2 * SIZE_SZ 的倍数。在x86中，SIZE_SZ是4，在x64中SIZE_SZ是8。</p>
<p>故在32位中最小的chunk(min_size)的大小为：8+4+4&#x3D;16字节,其中8字节为用户使用的空间，4字节为pre_size,4字节为chunk_size</p>
<p>64位最小为：16+8+8&#x3D;32字,16字节为用户使用的空间，8字节为pre_size,8字节为chunk_size（最小的chunk意味着只要用户申请的size小于min_size，得到的空间都为min_size）</p>
<p>这也就说明该字段的低三个比特位一定是0，所以我们可以把它们利用起来，三个比特位从高到低表示AMP。<br><strong>A:NON_MAIN_ARENA，记录当前的chunk是否不属于主线程，1表示不属于，0表示属于</strong><br><strong>M:IS_MAPPED记录当前chunk是否是由mmap分配的</strong><br><strong>P:PREV_INUSE，记录前一个chunk是否被分配，一般来说堆中的第一个被分配的chunk的size字段的P位都会是1，防止对前面的内存非法访问。当一个chunk的size的P位为<u>0</u>的时候，也就意味着前一个chunk空闲，也就是说当前chunk可以和前一个chunk合并</strong><br><strong>3、fd,bk，chunk</strong>处于分配状态的时候，<u>从fd字段开始都是用户的数据</u>，当chunk空闲的时候，会被添加到相对应的bins中，<strong>bins的话其实就是一个链表</strong>，有的是双向链表，有的是单向链表，既然是链表那就一定要有指针，这个就是指针，<strong>fd是指向下一个chunk的指针，bk是指向上一个chunk的指针</strong></p>
<p><strong>4、fd_nextsize，bk_nextsize，fd_nextsize</strong>表示前一个chunk的大小，bk_nextsize表示后一个chunk的大小，当然这个也是chunk空闲的时候采用，不过只有较大的chunk才会用到，也就是large chunk（一个bins的名称）。</p>
<p>一个已经分配的 chunk 的样子如下。<strong>我们称前两个字段称为 chunk header，后面的部分称为 user data。每次 malloc 申请得到的内存指针，其实指向 user data 的起始处。</strong></p>
<p>当一个 chunk 处于使用状态时，它的下一个 chunk 的 prev_size 域无效，所以下一个 chunk 的该部分也可以被当前 chunk 使用。<strong>这就是 chunk 中的空间复用。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Size of previous chunk, if unallocated (P clear)  |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Size of chunk, in bytes                     |A|M|P|</span><br><span class="line">  mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             User data starts here...                          .</span><br><span class="line">        .                                                               .</span><br><span class="line">        .             (malloc_usable_size() bytes)                      .</span><br><span class="line">next    .                                                               |</span><br><span class="line">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             (size of chunk, but used for application data)    |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Size of next chunk, in bytes                |A|0|1|</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure>

<p>被释放的 chunk 被记录在链表中（可能是循环双向链表，也可能是单向链表）。具体结构如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Size of previous chunk, if unallocated (P clear)  |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">`head:&#x27; |             Size of chunk, in bytes                     |A|0|P|</span><br><span class="line">  mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Forward pointer to next chunk in list             |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Back pointer to previous chunk in list            |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Unused space (may be 0 bytes long)                .</span><br><span class="line">        .                                                               .</span><br><span class="line"> next   .                                                               |</span><br><span class="line">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">`foot:&#x27; |             Size of chunk, in bytes                           |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Size of next chunk, in bytes                |A|0|0|</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure>

<p>可以发现，如果一个 chunk 处于 free 状态，那么会有两个位置记录其相应的大小</p>
<ol>
<li>本身的 size 字段会记录，</li>
<li>它后面的 chunk 会记录。</li>
</ol>
<p><strong>一般情况下</strong>，物理相邻的两个空闲 chunk 会被合并为一个 chunk 。堆管理器会通过 prev_size 字段以及 size 字段合并两个物理相邻的空闲 chunk 块。</p>
<h3 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h3><p><img src="https://skymirror-1322365871.cos.ap-beijing.myqcloud.com/v2-7b75a3daef17160b85a12410b93673a5_720w.webp" alt="v2-7b75a3daef17160b85a12410b93673a5_720w"></p>
<h2 id="bin（Free-Chunk）"><a href="#bin（Free-Chunk）" class="headerlink" title="bin（Free_Chunk）"></a>bin（Free_Chunk）</h2><h3 id="总概"><a href="#总概" class="headerlink" title="总概"></a>总概</h3><p><code>bins</code>就是空闲列表数据结构，它们用以保存 <code>free chunks</code>。根据其中chunk的大小，bins 被分为如下几种类型：</p>
<ul>
<li>unsorted bin                            不确定，未被归类的bin</li>
<li>fastbins【Y】(单项链表)         0x20~0x80                      </li>
<li>small bins                                 0x90~0x400</li>
<li>large bins                                  0x410以上</li>
</ul>
<p>用户释放掉的 chunk 不会马上归还给系统，ptmalloc 会统一管理 heap 和 mmap 映射区域中的空闲的 chunk。当用户再一次请求分配内存时，ptmalloc 分配器会试图在空闲的 chunk 中挑选一块合适的给用户。这样可以避免频繁的系统调用，降低内存分配的开销。</p>
<p>在具体的实现中，ptmalloc 采用分箱式方法对空闲的 chunk 进行管理。首先，它会根据空闲的 chunk 的大小以及使用状态将 chunk 初步分为 4 类：fast bins，small bins，large bins，unsorted bin。每类中仍然有更细的划分，相似大小的 chunk 会用双向链表链接起来。也就是说，在每类 bin 的内部仍然会有多个互不相关的链表来保存不同大小的 chunk。</p>
<p>对于 small bins，large bins，unsorted bin 来说，ptmalloc 将它们维护在同一个数组中。这些 bin 对应的数据结构在 malloc_state 中，如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define NBINS 128</span><br><span class="line">/* Normal bins packed as described above */</span><br><span class="line">mchunkptr bins[ NBINS * 2 - 2 ];</span><br></pre></td></tr></table></figure>

<p><code>bins</code> 主要用于索引不同 bin 的 fd 和 bk。</p>
<p>为了简化在双链接列表中的使用，每个 bin 的 header 都设置为 malloc_chunk 类型。这样可以避免 header 类型及其特殊处理。但是，为了节省空间和提高局部性，只分配 bin 的 fd&#x2F;bk 指针，然后使用 repositioning tricks 将这些指针视为一个<code>malloc_chunk*</code>的字段。</p>
<p>以 32 位系统为例，bins 前 4 项的含义如下</p>
<table>
<thead>
<tr>
<th>含义</th>
<th>bin1 的 fd&#x2F;bin2 的 prev_size</th>
<th>bin1 的 bk&#x2F;bin2 的 size</th>
<th>bin2 的 fd&#x2F;bin3 的 prev_size</th>
<th>bin2 的 bk&#x2F;bin3 的 size</th>
</tr>
</thead>
<tbody><tr>
<td>bin下标</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
</tr>
</tbody></table>
<p>可以看到，bin2 的 prev_size、size 和 bin1 的 fd、bk 是重合的。由于我们只会使用 fd 和 bk 来索引链表，所以该重合部分的数据其实记录的是 bin1 的 fd、bk。 也就是说，虽然后一个 bin 和前一个 bin 共用部分数据，但是其实记录的仍然是前一个 bin 的链表数据。通过这样的复用，可以节省空间。 </p>
<p>数组中的 bin 依次如下</p>
<ol>
<li><strong>第一个为 unsorted bin</strong>，字如其面，这里面的 chunk 没有进行排序，存储的 chunk 比较杂。</li>
<li><strong>索引从 2 到 63 的 bin 称为 small bin</strong>，同一个 small bin 链表中的 chunk 的大小相同。两个相邻索引的 small bin 链表中的 chunk 大小相差的字节数为 <strong>2 个机器字长</strong>，即 32 位相差 8 字节，64 位相差 16 字节。</li>
<li><strong>small bins 后面的 bin 被称作 large bins</strong>（64到126）。large bins 中的每一个 bin 都包含一定范围内的 chunk，其中的 chunk 按 fd 指针的顺序从大到小排列。相同大小的 chunk 同样按照最近使用顺序排列。</li>
</ol>
<p>此外，上述这些 bin 的排布都会遵循一个原则：<strong>任意两个物理相邻的free_chunk 不能在一起</strong>。</p>
<p>需要注意的是，并不是所有的 chunk 被释放后就立即被放到 bin 中。ptmalloc 为了提高分配的速度，会把一些小的 chunk <strong>先</strong>放到 fast bins 的容器内。<strong>而且，fastbin 容器中的 chunk 的使用标记总是被置位的，所以不满足上面的原则。</strong></p>
<h3 id="bin结构"><a href="#bin结构" class="headerlink" title="bin结构"></a>bin结构</h3><h4 id="small-bin-和unsorted-bin"><a href="#small-bin-和unsorted-bin" class="headerlink" title="small bin 和unsorted bin"></a>small bin 和unsorted bin</h4><p><strong>small bin有下面特点：</strong></p>
<ol>
<li><strong>使用双链表链接free chunk</strong></li>
<li><strong>同一个small bin的chunk size相同</strong></li>
<li><strong>一共62个small bin，chunk size大小从16字节开始，8字节递增，最大504字节</strong></li>
</ol>
<p><strong>unsorted bin 可以视为空闲 chunk 回归其所属 bin 之前的缓冲区。</strong></p>
<p>unsorted bin 处于我们之前所说的 bin 数组下标 1 处。故而 unsorted bin 只有一个链表。unsorted bin 中的空闲 chunk 处于乱序状态，主要有<strong>两个来源</strong></p>
<ul>
<li>所有大小大于fastbin的chunk都会被先暂时放入unsortedbin中，链表中的chunk大小并不一定</li>
<li>释放一个不属于 fast bin 的 chunk，并且该 chunk 不和 top chunk 紧邻时，该 chunk 会被首先放到 unsorted bin 中。</li>
</ul>
<p>此外，Unsorted Bin 在使用的过程中，采用的遍历顺序是 <strong>FIFO 。</strong>即插入的时候插入到 unsorted bin 的头部，取出的时候从链表尾获取。</p>
<p>在程序 malloc 时，如果在 fastbin，small bin 中找不到对应大小的 chunk，就会尝试从 Unsorted Bin 中寻找 chunk。如果取出来的 chunk 大小刚好满足，就会直接返回给用户，否则就会把这些 chunk 分别插入到对应的 bin 中。</p>
<p><img src="https://skymirror-1322365871.cos.ap-beijing.myqcloud.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-03-02%20200412.png" alt="屏幕截图 2024-03-02 200412"></p>
<h4 id="fast-bin"><a href="#fast-bin" class="headerlink" title="fast bin"></a>fast bin</h4><p>大多数程序经常会申请以及释放一些比较小的内存块。如果将一些较小的 chunk 释放之后发现存在与之相邻的空闲的 chunk 并将它们进行合并，那么当下一次再次申请相应大小的 chunk 时，就需要对 chunk 进行分割，这样就大大降低了堆的利用效率。<strong>因为我们把大部分时间花在了合并、分割以及中间检查的过程中。</strong>因此，ptmalloc 中专门设计了 fast bin，对应的变量就是 malloc state 中的 <strong>fastbinsY</strong></p>
<p><strong>malloc中的fast bin有下面几个特性：</strong></p>
<ol>
<li>fast bin用的是单链表而不是双链表，即只用了malloc_chunk中的fd这个指针，插入和删除chunk都是在表头进行</li>
<li>fast bin的P标志位都是1，通常情况下不对free_chunk进行合并</li>
<li>fast bin的chunk size是按照8字节递增的，</li>
<li>fastbin被free后，不会改变下一个的previnuse位，意思是不会被合并</li>
</ol>
<p><strong>fastbin在使用的过程中，采用的遍历顺序是 LIFO 。</strong></p>
<p><img src="https://skymirror-1322365871.cos.ap-beijing.myqcloud.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-03-02%20200743.png" alt="屏幕截图 2024-03-02 200743"></p>
<h4 id="large-bin"><a href="#large-bin" class="headerlink" title="large bin"></a>large bin</h4><p><img src="https://skymirror-1322365871.cos.ap-beijing.myqcloud.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-03-02%20200708.png" alt="屏幕截图 2024-03-02 200708"></p>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><h4 id="bin数组"><a href="#bin数组" class="headerlink" title="bin数组"></a>bin数组</h4><p>ptmalloc 把大小相似的 chunk，用双向链表连接起来，这样就形成了一个 bin。ptmalloc 一共维护了 128 个这样的 bin，并使用数组来存储这些 bin 如下：</p>
<p><img src="https://skymirror-1322365871.cos.ap-beijing.myqcloud.com/15548795-49ecc4bc156e439a%20(1).png" alt="15548795-49ecc4bc156e439a (1)"></p>
<p>再回到这张图，数组中的第一个 bin 是 unsorted bin，数组中从第 2 个到第 64 个 bin 是 small bin，它的 chunk size 依次递增 8bytes，每个 small bin 中的 chunk 大小相同。small bin 是一个双向链表。双向链表不是循环链表，它是有顺序的。<strong>在相同大小 chunk 的 bin 中 的排序是按照「最近使用」的顺序，也就是说，排在后面的最容易被选中，刚被释放的放在前面</strong>。</p>
<p>当空闲的 chunk 被连接到 bin 的时候，ptmalloc 会把表示该 chunk 是否正在使用的标志 p 设置为 0。（<strong>注意！这个标志实际处在下一个 chunk 中</strong>）。同时，ptmalloc 还会检查它前后（物理前后）的 chunk 是否为空，如果为空，ptmalloc 会把这些 chunk 合并成一个大的 chunk，然后把合并后的 chunk 放入 unsorted bin 中。但是对于较小的 chunk，ptmalloc 会把它放入 fast bins 中。</p>
<p>bins：用以保存unsorted、small以及large bins，共计可容纳126个：</p>
<ul>
<li>Bin 1 – unsorted bin</li>
<li>Bin 2 to Bin 63 – small bin(可索引大小&lt;512B的内存块)</li>
<li>Bin 64 to Bin 126 – large bin（可索引大小≥512B的内存块）</li>
</ul>
<h5 id="双项链表"><a href="#双项链表" class="headerlink" title="双项链表"></a>双项链表</h5><p><img src="https://skymirror-1322365871.cos.ap-beijing.myqcloud.com/v2-37c55951dbfc534f96b673fb10554ddd_720w%20(1).webp" alt="v2-37c55951dbfc534f96b673fb10554ddd_720w (1)"></p>
<h5 id="单项链表"><a href="#单项链表" class="headerlink" title="单项链表"></a>单项链表</h5><p><img src="https://skymirror-1322365871.cos.ap-beijing.myqcloud.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-03-02%20215727.png" alt="屏幕截图 2024-03-02 215727"></p>
<h3 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h3><p>内存回收的流程如下图所示：</p>
<p><img src="https://skymirror-1322365871.cos.ap-beijing.myqcloud.com/v2-e23b88b98b6828aad4052288cee427c6_720w.webp" alt="v2-e23b88b98b6828aad4052288cee427c6_720w"></p>
<p>bin可以分为4类：Fast bin、Unsorted bin、Small bin和 Large bin。保存这些bin的数据结构为fastbinsY以及bins：</p>
<p>fastbinsY：用以保存fast bins。（可索引大小16~64B的内存块）</p>
<p>bins：用以保存unsorted、small以及large bins，共计可容纳126个：</p>
<ul>
<li>Bin 1 – unsorted bin</li>
<li>Bin 2 to Bin 63 – small bin(可索引大小&lt;512B的内存块)</li>
<li>Bin 64 to Bin 126 – large bin（可索引大小≥512B的内存块）</li>
</ul>
<p>在内存被释放的时候，被释放内存块会根据其大小而被添加入对应的bin中：</p>
<ul>
<li>16~64B的内存块会被添加入fastbinY中</li>
<li>samll及large的会添加在bins中的unsorted bins中。</li>
</ul>
<p><strong>malloc内存回收流程</strong></p>
<ol>
<li>获取分配区的锁，保证线程安全。</li>
<li>如果free的是空指针，则返回，什么都不做。</li>
<li>判断当前chunk是否是mmap映射区域映射的内存，如果是，则直接munmap()释放这块内存。前面的已使用chunk的数据结构中，我们可以看到有M来标识是否是mmap映射的内存。</li>
<li>判断chunk是否与top chunk相邻，如果相邻，则直接和top chunk合并（和top chunk相邻相当于和分配区中的空闲内存块相邻）。转到步骤8</li>
<li>如果chunk的大小大于max_fast_bin（64b），则放入unsorted bin，并且检查是否有合并，有合并情况并且和top chunk相邻，则转到步骤8；没有合并情况则free。</li>
<li>如果chunk的大小小于 max_fast_bin（64b），则直接放入fast bin，fast bin并没有改变chunk的状态。没有合并情况，则free；有合并情况，转到步骤7</li>
<li>在fast bin，如果当前chunk的下一个chunk也是空闲的，则将这两个chunk合并，放入unsorted bin上面。合并后的大小如果大于64B，会触发进行fast bins的合并操作，fast bins中的chunk将被遍历，并与相邻的空闲chunk进行合并，合并后的chunk会被放到unsorted bin中，fast bin会变为空。合并后的chunk和topchunk相邻，则会合并到topchunk中。转到步骤8</li>
<li>判断top chunk的大小是否大于mmap收缩阈值（默认为128KB），如果是的话，对于主分配区，则会试图归还top chunk中的一部分给操作系统。free结束。</li>
</ol>
<h3 id="内存分配-1"><a href="#内存分配-1" class="headerlink" title="内存分配"></a>内存分配</h3><p>内存分配的流程如下图所示：</p>
<p><img src="https://skymirror-1322365871.cos.ap-beijing.myqcloud.com/v2-984d5a8c9fc11e2ea658d48cd847b121_720w.webp" alt="v2-984d5a8c9fc11e2ea658d48cd847b121_720w"></p>
<p>top chunk中找到（并分割出）所需内存块，其检索的优先级从高到低分别是：</p>
<ol>
<li>fastbinY</li>
<li>small bins</li>
<li>unsorted bins</li>
<li>large bins</li>
<li>top bins</li>
</ol>
<p><a href="Arena%E7%9A%84%E6%95%B0%E9%87%8F%E4%B8%8E%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E5%B9%B6%E4%B8%8D%E4%B8%80%E5%AE%9A%E6%98%AF%E4%B8%80%E4%B8%80%E6%98%A0%E5%B0%84%E7%9A%84%E5%85%B3%E7%B3%BB%E3%80%82">^tip</a>: Fast bin、Unsorted bin、Small bin和 Large bin中保存的都是用户曾经释放的内存块（可能经过合并）<br><a href="Arena%E7%9A%84%E6%95%B0%E9%87%8F%E4%B8%8E%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E5%B9%B6%E4%B8%8D%E4%B8%80%E5%AE%9A%E6%98%AF%E4%B8%80%E4%B8%80%E6%98%A0%E5%B0%84%E7%9A%84%E5%85%B3%E7%B3%BB%E3%80%82">^tip</a>:  top chunk包含Arena扩容的部分，不属于任何bin！</p>
<p><strong>malloc内存分配流程</strong></p>
<p>1、获取分配区的锁，防止多线程冲突。（一个进程有一个malloc管理器，而一个进程中的多个线程共享这一个管理器，有竞争，加锁）</p>
<p>2、计算出实际需要分配的内存的chunk实际大小。</p>
<p>3、判断chunk的大小，如果小于max_fast（64Ｂ），则尝试去fast bins上取<strong>适合（大小合适，不进行分割）</strong>的chunk，如果有则分配结束。否则，下一步；</p>
<p>4、判断chunk大小是否小于512B，如果是，则从small bins上去查找chunk，如果有合适的，则分配结束。否则下一步；</p>
<p>5、ptmalloc首先会遍历fast bins（注：这里是第二次遍历fast bins了，虽然fast bins一般不会合并，但此时会）中的chunk，将相邻的chunk进行合并，并链接到unsorted bin中然后遍历 unsorted bins。（总体而言，第五部遍历unsorted bin，只是在遍历前先合并fast bin，遍历unsorted bin时一边遍历，一边放到small bin和large bin中）</p>
<p>如果unsorted bins上只有一个chunk并且大于待分配的chunk，则进行切割，并且剩余的chunk继续扔回unsorted bins； 如果unsorted bins上有大小和待分配chunk相等的，则返回，并从unsorted bins删除； 如果unsorted bins中的某一chunk大小 属于small bins的范围，则放入small bins的头部； 如果unsorted bins中的某一chunk大小 属于large bins的范围，则找到合适的位置放入。若未分配成功，转入下一步； </p>
<p>6、从large bins中查找找到合适的chunk之后，然后进行切割，一部分分配给用户，剩下的放入unsorted bin中。</p>
<p>7、如果搜索fast bins和bins都没有找到合适的chunk，那么就需要操作top chunk来进行分配了 。当top chunk大小比用户所请求大小还大的时候，top chunk会分为两个部分：User chunk（用户请求大小）和Remainder chunk（剩余大小）。其中Remainder chunk成为新的top chunk。 当top chunk大小小于用户所请求的大小时，top chunk就通过sbrk（main arena）或mmap（thread arena）系统调用来扩容。</p>
<p>8、到了这一步，说明 top chunk 也不能满足分配要求，所以，于是就有了两个选择: 如 果是主分配区，调用 sbrk()，增加 top chunk 大小；如果是非主分配区，调用 mmap 来分配一个新的 sub-heap，增加 top chunk 大小；或者使用 mmap()来直接分配。在 这里，需要依靠 chunk 的大小来决定到底使用哪种方法。判断所需分配的 chunk 大小是否大于等于 mmap 分配阈值，如果是的话，则转下一步，调用 mmap 分配， 否则跳到第 10 步，增加 top chunk 的大小。</p>
<p>9、使用 mmap 系统调用为程序的内存空间映射一块 chunk_size align 4kB 大小的空间。 然后将内存指针返回给用户。</p>
<p>10、判断是否为第一次调用 malloc，若是主分配区，则需要进行一次初始化工作，分配 一块大小为(chunk_size + 128KB) align 4KB 大小的空间作为初始的 heap。若已经初 始化过了，主分配区则调用 sbrk()增加 heap 空间，分主分配区则在 top chunk 中切 割出一个 chunk，使之满足分配需求，并将内存指针返回给用户。</p>
<h2 id="Top-Chunk"><a href="#Top-Chunk" class="headerlink" title="Top Chunk"></a>Top Chunk</h2><p>程序第一次进行 malloc 的时候，heap 会被分为两块，一块给用户，剩下的那块就是 top chunk。其实，所谓的 top chunk 就是处于当前堆的物理地址最高的 chunk。这个 chunk 不属于任何一个 bin，它的作用在于当所有的 bin 都无法满足用户请求的大小时，如果其大小不小于指定的大小，就进行分配，并将剩下的部分作为新的 top chunk。否则，就对 heap 进行扩展后再进行分配。在 main arena 中通过 sbrk 扩展 heap，而在 thread arena 中通过 mmap 分配新的 heap。</p>
<p><strong>需要注意的是，top chunk 的 prev_inuse 比特位始终为 1，否则其前面的 chunk 就会被合并到 top chunk 中。</strong></p>
<p><strong>初始情况下，我们可以将 unsorted chunk 作为 top chunk。</strong></p>
<h1 id="堆利用"><a href="#堆利用" class="headerlink" title="堆利用"></a>堆利用</h1><h2 id="malloc-hook以及free-hook劫持"><a href="#malloc-hook以及free-hook劫持" class="headerlink" title="malloc_hook以及free_hook劫持"></a>malloc_hook以及free_hook劫持</h2><h3 id="劫持原理"><a href="#劫持原理" class="headerlink" title="劫持原理"></a>劫持原理</h3><ul>
<li>malloc_hook位于main_arena上方-0x10的位置，可以通过fake chunk来overwrite该值实现getshell</li>
<li>free_hook 位于libc上_free_hook上，可以通过fake chunk来overwrite该值达到劫持程序流的目的</li>
</ul>
<h3 id="malloc-hook"><a href="#malloc-hook" class="headerlink" title="malloc_hook"></a>malloc_hook</h3><h4 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h4><p>在执行malloc时，会检测__malloc_hook的值，如果malloc_hook的值存在，将调用malloc_hook指向的地址call rax，如果我们将该值overite 为one_gadget，当程序执行malloc的时候，便可以getshell</p>
<h4 id="利用过程"><a href="#利用过程" class="headerlink" title="利用过程"></a>利用过程</h4><ul>
<li>用<code>p &amp;__malloc_hook</code>指令打印出malloc_hook存储的位置</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ p &amp;__malloc_hook</span><br><span class="line">$2 = (void *(**)(size_t, const void *)) 0x7ffff7dd5b10 &lt;__malloc_hook&gt;</span><br><span class="line">gdb-peda$ p &amp;main_arena</span><br><span class="line">$3 = (struct malloc_state *) 0x7ffff7dd5b20 &lt;main_arena&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>在malloc_hook 上方查找满足条件的fastbin 的size</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ x/8gx  0x7ffff7dd5b00-0x20</span><br><span class="line">0x7ffff7dd5ae0 &lt;_IO_wide_data_0+288&gt;:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x7ffff7dd5af0 &lt;_IO_wide_data_0+304&gt;:	0x00007ffff7dd4260	0x0000000000000000</span><br><span class="line">0x7ffff7dd5b00 &lt;__memalign_hook&gt;:	0x00007ffff7ac0305	0x00007ffff7ac02c6</span><br><span class="line">0x7ffff7dd5b10 &lt;__malloc_hook&gt;:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure>
</li>
<li><p>查找符合条件的fake_fastbin,pwndbg内置了查找符合条件的fake_fast_bin的命令</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ find_fake_fast 0x7ffff7dd5b10 0x7f</span><br><span class="line">FAKE CHUNKS</span><br><span class="line">Fake chunk | Allocated chunk | PREV_INUSE | IS_MMAPED | NON_MAIN_ARENA</span><br><span class="line">Addr: 0x7ffff7dd5aed</span><br><span class="line">prev_size: 0xfff7ac02c600007f</span><br><span class="line">size: 0x7f</span><br><span class="line">fd: 0x00</span><br><span class="line">bk: 0x7f</span><br><span class="line">fd_nextsize: 0xfff7ac0305000000</span><br><span class="line">bk_nextsize: 0xfff7dd4260000000</span><br></pre></td></tr></table></figure>

<p>伪造的fastbin的addr为0x7ffff7dd5aed，当程序可以在该位置申请chunk的时候，便可以达到程序流劫持getshell</p>
<h3 id="free-hook"><a href="#free-hook" class="headerlink" title="free_hook"></a>free_hook</h3><h4 id="利用思路-1"><a href="#利用思路-1" class="headerlink" title="利用思路"></a>利用思路</h4><ul>
<li>通过改写main_arena中的top_chunk的地址，将top_chunk的值改写到<strong>free_hook上方指定的位置，通过不断向top_chunk申请chunk，最终可以分配到包含</strong>free_hook的区块，从而可以改写__free_hook的值。</li>
<li>通过改写global_max_fast的值，可以在free_hook的上方找到一个足够大包含free_hook的块，当改写了global_max_fast后，向heap申请的块都将按照fastbin来处理</li>
<li>通过unsorted bin attack 在free_hook上方<strong>伪造 0x7f大小的chunk</strong>,再通过fastbin attack 来修改free_hoook的值</li>
</ul>
<h4 id="利用过程-1"><a href="#利用过程-1" class="headerlink" title="利用过程"></a>利用过程</h4><ol>
<li>修改top_chunk</li>
</ol>
<p>用<code>p &amp;__free_hook</code>指令查找free_hook存储位置</p>
<ul>
<li><strong>free_hook的存储的位置,在 free_hook上方 -0xb58 我们可以找到满足top_chunk要求的大小</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ p &amp;__free_hook</span><br><span class="line">$5 = (void (**)(void *, const void *)) 0x7ffff7dd77a8 &lt;__free_hook&gt;</span><br><span class="line">gdb-peda$ x/8gx 0x7ffff7dd77a8 -0xb58</span><br><span class="line">0x7ffff7dd6c50 &lt;initial+16&gt;:	0x0000000000000004	0x697b5349788728d7</span><br><span class="line">0x7ffff7dd6c60 &lt;initial+32&gt;:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x7ffff7dd6c70 &lt;initial+48&gt;:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure>

<ul>
<li>伪造的fastbin的addr为0x7ffff7dd6c50，当程序可以在该位置申请chunk的时候，通过重复向top_chunk申请，最终覆写__free_hook的值为system的值通过free &#x2F;bin&#x2F;sh\x00的chunk,达到程序流劫持getshell。</li>
</ul>
<ol start="2">
<li>修改global_max_fast,但是这依赖于可以malloc的chunk的大小是可控的</li>
</ol>
<ul>
<li>通过fastbin attack 使得可以malloc 指定包含free_hook大小的chunk，比如利用0x7ffff7dd6c58处的值，但是这里要合理去构造偏移</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ x/200gx 0x7ffff7dd77a8-0xC00</span><br><span class="line">0x7ffff7dd6ba8 &lt;lock+8&gt;:	0x0000000000000000	0x0000000000000000</span><br><span class="line">....</span><br><span class="line">0x7ffff7dd6c48 &lt;initial+8&gt;:	0x0000000000000001	0x0000000000000004</span><br><span class="line">0x7ffff7dd6c58 &lt;initial+24&gt;:	0xbf378114d045c300	0x0000000000000000</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>通过unsorted_bin attack 来写入free_hook上方0x7f的值，可以在free_hook上方伪造出0x7f大小的chunk,再可以通过fastbin attack 来malloc得到包含free_hook的chunk，写入system的地址，通过free(&#x2F;bin&#x2F;sh)来实现利用。</li>
</ol>
<h2 id="UAF"><a href="#UAF" class="headerlink" title="UAF"></a>UAF</h2><p><em><strong>Use after free（释放后再利用）</strong></em>     </p>
<p><strong>构造UAF是堆漏洞利用的核心</strong>  ，   </p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><strong>内存被释放之后，指针没有被设置为NULL，利用其他指针对这一块内存进行了修改</strong></p>
<p><strong>UAF成因：</strong></p>
<ul>
<li><strong>堆溢出</strong></li>
<li><strong>指针悬挂</strong></li>
<li><strong>overlap</strong></li>
</ul>
<h2 id="Unlink"><a href="#Unlink" class="headerlink" title="Unlink"></a>Unlink</h2><h3 id="利用思路-2"><a href="#利用思路-2" class="headerlink" title="利用思路"></a>利用思路</h3><h4 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h4><ol>
<li><strong>UAF ，可修改 free 状态下 smallbin 或是 unsorted bin 的 fd 和 bk 指针</strong></li>
<li><strong>已知位置存在一个指针指向可进行 UAF 的 chunk</strong></li>
</ol>
<h4 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h4><p> <strong>使得已指向 UAF chunk 的指针 ptr 变为 ptr - 0x18</strong></p>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p><strong>设指向可 UAF chunk 的指针的地址为 ptr</strong></p>
<ol>
<li><strong>修改 fd 为 ptr - 0x18</strong></li>
<li><strong>修改 bk 为 ptr - 0x10</strong></li>
<li><strong>触发 unlink</strong></li>
</ol>
<p><strong>ptr 处的指针会变为 ptr - 0x18。</strong></p>
<h2 id="Fastbin-Attack"><a href="#Fastbin-Attack" class="headerlink" title="Fastbin Attack"></a>Fastbin Attack</h2><ul>
<li><p>第一大攻击手法</p>
</li>
<li><p>分配的size段必须合适</p>
</li>
<li><p>程序不允许我们连续释放同一个堆块</p>
</li>
</ul>
<h3 id="已经有了UAF"><a href="#已经有了UAF" class="headerlink" title="已经有了UAF"></a>已经有了UAF</h3><ul>
<li>直接修改fd指针</li>
<li>分配的目标地址附近一定要有个头部size字段</li>
<li>size字段比较好找，因为libc中函数地址的指针都是形如：0x7fxxxxxxx，把偏移改一下，就会得到一个0x7f，由于堆块都是0x10字节对齐的，所以会被当成0x70处理</li>
<li>修改的地方是_malloc_hook或者got表或者栈</li>
</ul>
<h3 id="没有UAF，但是有指针悬挂"><a href="#没有UAF，但是有指针悬挂" class="headerlink" title="没有UAF，但是有指针悬挂"></a>没有UAF，但是有指针悬挂</h3><ul>
<li>没有直接的UAF，但是我们可以访问到被free掉的指针</li>
<li>需要利用fastbin来构造UAF</li>
</ul>
<h2 id="Ubsortedbin-attack"><a href="#Ubsortedbin-attack" class="headerlink" title="Ubsortedbin attack"></a>Ubsortedbin attack</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><ul>
<li><p>第二大攻击手法</p>
</li>
<li><p>最简单的攻击手法，前提条件是UAF</p>
</li>
<li><p>任意地址内存写一个不确定的非常大的数（libc 地址）</p>
</li>
<li><p>通常，我们利用unsortedbin attack 来修改一些类似于修改次数限制、上限信息、伪造堆头、配合局部写等等</p>
</li>
</ul>
<h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><ul>
<li><p>利用前提是先有UAF，修改unsorted bin 中的的BK字段为target addr - 0x10,</p>
<p>然后malloc一个相同大小的chunk,即可完成攻击</p>
</li>
<li><p>Unsorted Bin 在使用的过程中，采用的遍历顺序是FIFO，即插入的时候插入到unsorted bin 的头部，取出的时候从链表尾获取</p>
</li>
<li><p>在程序malloc时，如果在fastbin ,small bin 中找不到对于大小的chunk，就会尝试从Unsorted Bin 中寻找chunk。如果取出来的chunk大小刚好满足，就会直接返回给用户，否则就会把这些chunk分别插入到对应的bin中</p>
</li>
</ul>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p><strong>直接将<code>bck-&gt;fd</code> 改变</strong></p>
<p>unsorted bin attack 确实可以修改任意地址的值，但是所修改成的值却不受我们控制，唯一可以知道的是，这个值比较大。<strong>而且，需要注意的是，</strong></p>
<p>这看起来似乎并没有什么用处，但是其实还是有点卵用的，比如说</p>
<ul>
<li>我们通过修改循环的次数来使得程序可以执行多次循环。</li>
<li>我们可以修改 heap 中的 global_max_fast 来使得更大的 chunk 可以被视为 fast bin，这样我们就可以去执行一些 fast bin attack 了。</li>
</ul>
<h2 id="Off-By-One"><a href="#Off-By-One" class="headerlink" title="Off By One"></a>Off By One</h2><p><em><strong>特点：只溢出了一个字节</strong></em></p>
<h3 id="利用思路-3"><a href="#利用思路-3" class="headerlink" title="利用思路"></a>利用思路</h3><ol>
<li>溢出字节为可控制任意字节：通过修改大小造成块结构之间出现重叠，从而泄露其他块数据，或是覆盖其他块数据。也可使用 NULL 字节溢出的方法</li>
<li>溢出字节为 NULL 字节：在 size 为 0x100 的时候，溢出 NULL 字节可以使得 <code>prev_in_use</code> 位被清，这样前块会被认为是 free 块。<ol>
<li>这时可以选择使用 unlink 方法（见 unlink 部分）进行处理。</li>
<li>另外，这时 <code>prev_size</code> 域就会启用，就可以伪造 <code>prev_size</code> ，从而造成块之间发生重叠。此方法的关键在于 unlink 的时候没有检查按照 <code>prev_size</code> 找到的块的大小与<code>prev_size</code> 是否一致。</li>
</ol>
</li>
</ol>
<h2 id="house-of-force"><a href="#house-of-force" class="headerlink" title="house_of force"></a>house_of force</h2><p><strong>House Of Force</strong> 是一种堆利用方法，但是并不是说 House Of Force 必须得基于堆漏洞来进行利用。如果一个堆 (heap based) 漏洞想要通过 House Of Force 方法进行利用，需要以下<strong>条件</strong>：</p>
<ol>
<li>能够以溢出等方式控制到 top chunk 的 size 域</li>
<li>能够自由地控制堆分配尺寸的大小</li>
</ol>
<p>House Of Force 产生的原因在于 glibc 对 top chunk 的处理，根据前面堆数据结构部分的知识我们得知，进行堆分配时，如果所有空闲的块都无法满足需求，那么就会从 top chunk 中分割出相应的大小作为堆块的空间。</p>
<p>那么，当使用 top chunk 分配堆块的 size 值是由用户控制的任意值时会发生什么？答案是，可以使得 top chunk 指向我们期望的任何位置，这就相当于一次任意地址写。</p>
<ul>
<li><p><strong>在 glibc 中，会对用户请求的大小和 top chunk 现有的 size 进行验证</strong></p>
</li>
<li><p><strong>如果可以篡改 size 为一个很大值，就可以轻松的通过这个验证</strong></p>
<p><strong>一般的做法是把 top chunk 的 size 改为 (- 1)，因为在进行比较时会把 size 转换成无符号数，因此 -1 也就是说 unsigned long 中最大的数，所以无论如何都可以通过验证。</strong></p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">remainder      = chunk_at_offset(victim, nb);</span><br><span class="line">av-&gt;top        = remainder;</span><br><span class="line"></span><br><span class="line">/* Treat space at ptr + offset as a chunk */</span><br><span class="line">#define chunk_at_offset(p, s) ((mchunkptr)(((char *) (p)) + (s)))</span><br></pre></td></tr></table></figure>

<p>之后这里会把 top 指针更新，接下来的堆块就会分配到这个位置，用户只要控制了这个指针就相当于实现<strong>任意地址写任意值</strong> (write-anything-anywhere)。</p>
<p><strong><u>与此同时，我们需要注意的是，topchunk 的 size 也会更新</u></strong></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://sssxc.xyz">XC-lei</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://sssxc.xyz/CTF/pwn/Heap/">http://sssxc.xyz/CTF/pwn/Heap/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://sssxc.xyz" target="_blank">Xcs</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%A0%86%E6%BC%8F%E6%B4%9E/">堆漏洞</a></div><div class="post_share"><div class="social-share" data-image="https://skymirror-1322365871.cos.ap-beijing.myqcloud.com/Image_1699885009870.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/CTF/pwn/format/" title="format_"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">format_</div></div></a></div></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://skymirror-1322365871.cos.ap-beijing.myqcloud.com/Image_1699885009870.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">XC-lei</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">6</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A0%86%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.</span> <span class="toc-text">堆介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#malloc-and-free"><span class="toc-number">1.2.</span> <span class="toc-text">malloc and free</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#malloc"><span class="toc-number">1.2.0.1.</span> <span class="toc-text">malloc</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%EF%BC%9A"><span class="toc-number">1.2.0.1.1.</span> <span class="toc-text">定义：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#free"><span class="toc-number">1.2.0.2.</span> <span class="toc-text">free</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%EF%BC%9A-1"><span class="toc-number">1.2.0.2.1.</span> <span class="toc-text">定义：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BRK-and-MMAP"><span class="toc-number">1.2.0.3.</span> <span class="toc-text">BRK and MMAP</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#arena"><span class="toc-number">1.3.</span> <span class="toc-text">arena</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#arena%E6%95%B0%E9%87%8F"><span class="toc-number">1.3.1.</span> <span class="toc-text">arena数量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#arena-%E5%88%86%E9%85%8D%E8%A7%84%E5%88%99"><span class="toc-number">1.3.2.</span> <span class="toc-text">arena 分配规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tips"><span class="toc-number">1.3.3.</span> <span class="toc-text">tips</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#main-arena%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E7%94%B3%E8%AF%B7"><span class="toc-number">1.3.4.</span> <span class="toc-text">main arena中的内存申请</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E6%AC%A1%E7%94%B3%E8%AF%B7"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">第一次申请</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8E%E7%BB%AD%E7%94%B3%E8%AF%B7"><span class="toc-number">1.3.4.2.</span> <span class="toc-text">后续申请</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#thread-arena%E4%B8%AD%E7%9A%84%E7%94%B3%E8%AF%B7"><span class="toc-number">1.3.5.</span> <span class="toc-text">thread arena中的申请</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#malloc-state"><span class="toc-number">1.3.6.</span> <span class="toc-text">malloc_state</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Malloc-Chunk"><span class="toc-number">1.4.</span> <span class="toc-text">Malloc_Chunk</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.4.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#malloc-chunk%E7%BB%93%E6%9E%84"><span class="toc-number">1.4.2.</span> <span class="toc-text">malloc chunk结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-number">1.4.3.</span> <span class="toc-text">内存分配</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bin%EF%BC%88Free-Chunk%EF%BC%89"><span class="toc-number">1.5.</span> <span class="toc-text">bin（Free_Chunk）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E6%A6%82"><span class="toc-number">1.5.1.</span> <span class="toc-text">总概</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bin%E7%BB%93%E6%9E%84"><span class="toc-number">1.5.2.</span> <span class="toc-text">bin结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#small-bin-%E5%92%8Cunsorted-bin"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">small bin 和unsorted bin</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fast-bin"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">fast bin</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#large-bin"><span class="toc-number">1.5.2.3.</span> <span class="toc-text">large bin</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.5.2.4.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#bin%E6%95%B0%E7%BB%84"><span class="toc-number">1.5.2.5.</span> <span class="toc-text">bin数组</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%8C%E9%A1%B9%E9%93%BE%E8%A1%A8"><span class="toc-number">1.5.2.5.1.</span> <span class="toc-text">双项链表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%95%E9%A1%B9%E9%93%BE%E8%A1%A8"><span class="toc-number">1.5.2.5.2.</span> <span class="toc-text">单项链表</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6"><span class="toc-number">1.5.3.</span> <span class="toc-text">内存回收</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D-1"><span class="toc-number">1.5.4.</span> <span class="toc-text">内存分配</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Top-Chunk"><span class="toc-number">1.6.</span> <span class="toc-text">Top Chunk</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A0%86%E5%88%A9%E7%94%A8"><span class="toc-number">2.</span> <span class="toc-text">堆利用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#malloc-hook%E4%BB%A5%E5%8F%8Afree-hook%E5%8A%AB%E6%8C%81"><span class="toc-number">2.1.</span> <span class="toc-text">malloc_hook以及free_hook劫持</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%AB%E6%8C%81%E5%8E%9F%E7%90%86"><span class="toc-number">2.1.1.</span> <span class="toc-text">劫持原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#malloc-hook"><span class="toc-number">2.1.2.</span> <span class="toc-text">malloc_hook</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E6%80%9D%E8%B7%AF"><span class="toc-number">2.1.2.1.</span> <span class="toc-text">利用思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">2.1.2.2.</span> <span class="toc-text">利用过程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#free-hook"><span class="toc-number">2.1.3.</span> <span class="toc-text">free_hook</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E6%80%9D%E8%B7%AF-1"><span class="toc-number">2.1.3.1.</span> <span class="toc-text">利用思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E8%BF%87%E7%A8%8B-1"><span class="toc-number">2.1.3.2.</span> <span class="toc-text">利用过程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UAF"><span class="toc-number">2.2.</span> <span class="toc-text">UAF</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">2.2.1.</span> <span class="toc-text">原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Unlink"><span class="toc-number">2.3.</span> <span class="toc-text">Unlink</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E6%80%9D%E8%B7%AF-2"><span class="toc-number">2.3.1.</span> <span class="toc-text">利用思路</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6"><span class="toc-number">2.3.1.1.</span> <span class="toc-text">条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%88%E6%9E%9C"><span class="toc-number">2.3.1.2.</span> <span class="toc-text">效果</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF"><span class="toc-number">2.3.1.3.</span> <span class="toc-text">思路</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Fastbin-Attack"><span class="toc-number">2.4.</span> <span class="toc-text">Fastbin Attack</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%B2%E7%BB%8F%E6%9C%89%E4%BA%86UAF"><span class="toc-number">2.4.1.</span> <span class="toc-text">已经有了UAF</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B2%A1%E6%9C%89UAF%EF%BC%8C%E4%BD%86%E6%98%AF%E6%9C%89%E6%8C%87%E9%92%88%E6%82%AC%E6%8C%82"><span class="toc-number">2.4.2.</span> <span class="toc-text">没有UAF，但是有指针悬挂</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Ubsortedbin-attack"><span class="toc-number">2.5.</span> <span class="toc-text">Ubsortedbin attack</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-1"><span class="toc-number">2.5.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-1"><span class="toc-number">2.5.2.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%B3%95"><span class="toc-number">2.5.3.</span> <span class="toc-text">用法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Off-By-One"><span class="toc-number">2.6.</span> <span class="toc-text">Off By One</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E6%80%9D%E8%B7%AF-3"><span class="toc-number">2.6.1.</span> <span class="toc-text">利用思路</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#house-of-force"><span class="toc-number">2.7.</span> <span class="toc-text">house_of force</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/CTF/pwn/Heap/" title="heap_">heap_</a><time datetime="2024-04-18T11:49:19.062Z" title="发表于 2024-04-18 19:49:19">2024-04-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/CTF/pwn/format/" title="format_">format_</a><time datetime="2024-04-18T11:49:19.061Z" title="发表于 2024-04-18 19:49:19">2024-04-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/CTF/pwn/Stack/" title="stack_">stack_</a><time datetime="2024-01-20T13:02:43.430Z" title="发表于 2024-01-20 21:02:43">2024-01-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/CTF/%E5%B7%A5%E5%85%B7/gdb/" title="gdb的使用">gdb的使用</a><time datetime="2024-01-20T13:02:42.081Z" title="发表于 2024-01-20 21:02:42">2024-01-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/CTF/%E5%B7%A5%E5%85%B7/chat%20GPT/" title="chat GPT"><img src="https://skymirror-1322365871.cos.ap-beijing.myqcloud.com/pexels-sebastiaan-stam-1480690.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="chat GPT"/></a><div class="content"><a class="title" href="/CTF/%E5%B7%A5%E5%85%B7/chat%20GPT/" title="chat GPT">chat GPT</a><time datetime="2023-11-16T04:51:47.843Z" title="发表于 2023-11-16 12:51:47">2023-11-16</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://skymirror-1322365871.cos.ap-beijing.myqcloud.com/pexels-sebastiaan-stam-1480691.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By XC-lei</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"></div><div id="rightside-config-show"><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const initValine = () => {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'vObQE3oSG0duecRgH4T9yp8K-gzGzoHsz',
      appKey: 'Ra7v15YrsapkpYCFJkR46yMR',
      avatar: 'monsterid',
      serverURLs: 'https://vobqe3os.lc-cn-n1-shared.com',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  const loadValine = async () => {
    if (typeof Valine === 'function') initValine()
    else {
      await getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js')
      initValine()
    }
  }

  if ('Valine' === 'Valine' || !false) {
    if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>